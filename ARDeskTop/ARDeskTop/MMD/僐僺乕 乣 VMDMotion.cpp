//***************
// VMDモーション
//***************

#include	<stdio.h>
#include	<stdlib.h>
#include	<malloc.h>
#include	<string.h>
#include	"VMDMotion.h"


//------------------------------
// ボーンキーフレームソート用比較関数
//------------------------------
static int boneCompareFunc( const void *pA, const void *pB )
{
//	return (int)(((BoneKeyFrame *)pA)->fFrameNo - ((BoneKeyFrame *)pB)->fFrameNo);
}

//------------------------------
// 表情キーフレームソート用比較関数
//------------------------------
static int faceCompareFunc( const void *pA, const void *pB )
{
//	return (int)(((FaceKeyFrame *)pA)->fFrameNo - ((FaceKeyFrame *)pB)->fFrameNo);
}

//================
// コンストラクタ
//================
cVMDMotion::cVMDMotion( void ) : m_pMotionDataList( NULL ), m_pFaceDataList( NULL )
{
}

//==============
// デストラクタ
//==============
cVMDMotion::~cVMDMotion( void )
{
	release();
}

//====================
// ファイルの読み込み
//====================
bool cVMDMotion::load( const char *szFilePath )
{
	FILE	*pFile;
	fpos_t	fposFileSize;
	unsigned char
			*pData;

	pFile = fopen( szFilePath, "rb" );
	if( !pFile )	return false;	// ファイルが開けない

	// ファイルサイズ取得
	fseek( pFile, 0, SEEK_END );
	fgetpos( pFile, &fposFileSize );

	// メモリ確保
	pData = (unsigned char *)malloc( (size_t)fposFileSize );

	// 読み込み
	fseek( pFile, 0, SEEK_SET );
	fread( pData, 1, (size_t)fposFileSize, pFile );

	fclose( pFile );

	// モーションデータ初期化
	bool	bRet = initialize( pData );

	free( pData );

	return bRet;
}

//==========================
// モーションデータの初期化
//==========================
bool cVMDMotion::initialize( unsigned char *pData )
{
	release();

	// ヘッダのチェック
	VMD_Header	*pVMDHeader = (VMD_Header *)pData;
	if( strncmp( pVMDHeader->szHeader, "Vocaloid Motion Data 0002", 30 ) != 0 )
		return false;	// ファイル形式が違う

	pData += sizeof( VMD_Header );

	//-----------------------------------------------------
	// ボーンのキーフレーム数を取得
	unsigned long	ulNumBoneKeyFrames = *((unsigned long *)pData);
	pData += sizeof( unsigned long );

	// まずはモーションデータ中のボーンごとのキーフレーム数をカウント
	VMD_Motion		*pVMDMotion = (VMD_Motion *)pData;
	MotionDataList	*pMotTemp;

	m_fMaxFrame = 0.0f;
	for( unsigned long i = 0 ; i < ulNumBoneKeyFrames ; i++, pVMDMotion++ )
	{
		if( m_fMaxFrame < (float)pVMDMotion->ulFrameNo )	m_fMaxFrame = (float)pVMDMotion->ulFrameNo;	// 最大フレーム更新

		pMotTemp = m_pMotionDataList;

		while( pMotTemp )
		{
			if( strncmp( pMotTemp->szBoneName, pVMDMotion->szBoneName, 15 ) == 0 )
			{
				// リストに追加済みのボーン
				pMotTemp->ulNumKeyFrames++;
				break;
			}
			pMotTemp = pMotTemp->pNext;
		}

		if( !pMotTemp )
		{
			// リストにない場合は新規ノードを追加
			MotionDataList	*pNew = new MotionDataList;

			strncpy( pNew->szBoneName, pVMDMotion->szBoneName, 15 );	pNew->szBoneName[15] = '\0';
			pNew->ulNumKeyFrames = 1;
			pNew->pKeyFrameList = NULL;		// 追加

			pNew->pNext = m_pMotionDataList;
			m_pMotionDataList = pNew;
		}
	}

#if (0)
	// キーフレーム配列を確保
	pMotTemp = m_pMotionDataList;
	m_ulNumMotionNodes = 0;
	while( pMotTemp )
	{
		pMotTemp->pKeyFrameList = new BoneKeyFrame[pMotTemp->ulNumKeyFrames];
		pMotTemp->ulNumKeyFrames = 0;		// 配列インデックス用にいったん0にする
		pMotTemp = pMotTemp->pNext;

		m_ulNumMotionNodes++;
	}
#endif

	// ボーンごとにキーフレームを格納
	pVMDMotion = (VMD_Motion *)pData;

	for( unsigned long i = 0 ; i < ulNumBoneKeyFrames ; i++, pVMDMotion++ )
	{
		pMotTemp = m_pMotionDataList;

		while( pMotTemp )
		{
			if( strncmp( pMotTemp->szBoneName, pVMDMotion->szBoneName, 15 ) == 0 )
			{
			//	BoneKeyFrame	*pKeyFrame = &(pMotTemp->pKeyFrameList[pMotTemp->ulNumKeyFrames]);

				BoneKeyFrameList	*pKeyFrame = new BoneKeyFrameList;
				pKeyFrame->pNext = 0;

				pKeyFrame->fFrameNo     = (float)pVMDMotion->ulFrameNo;
				pKeyFrame->vec3Position = pVMDMotion->vec3Position;
				QuaternionNormalize( &pKeyFrame->vec4Rotate, &pVMDMotion->vec4Rotate );

			//	pMotTemp->ulNumKeyFrames++;

				if( !pMotTemp->pKeyFrameList )
				{
					pMotTemp->pKeyFrameList = pKeyFrame;
				}
				else
				{
					pKeyFrame->pNext = pMotTemp->pKeyFrameList;
					pMotTemp->pKeyFrameList = pKeyFrame;
				}

				break;
			}
			pMotTemp = pMotTemp->pNext;
		}
	}

	// キーフレーム配列を昇順にソート
	pMotTemp = m_pMotionDataList;

	while( pMotTemp )
	{
	//	qsort( pMotTemp->pKeyFrameList, pMotTemp->ulNumKeyFrames, sizeof( BoneKeyFrame ), boneCompareFunc );
		sortByFrame( pMotTemp );
		pMotTemp = pMotTemp->pNext;
	}

	pData += sizeof( VMD_Motion ) * ulNumBoneKeyFrames;

	//-----------------------------------------------------
	// 表情のキーフレーム数を取得
	unsigned long	ulNumFaceKeyFrames = *((unsigned long *)pData);
	pData += sizeof( unsigned long );

	// モーションデータ中の表情ごとのキーフレーム数をカウント
	VMD_Face		*pVMDFace = (VMD_Face *)pData;
	FaceDataList	*pFaceTemp;

	for( unsigned long i = 0 ; i < ulNumFaceKeyFrames ; i++, pVMDFace++ )
	{
		if( m_fMaxFrame < (float)pVMDFace->ulFrameNo )	m_fMaxFrame = (float)pVMDFace->ulFrameNo;	// 最大フレーム更新

		pFaceTemp = m_pFaceDataList;

		while( pFaceTemp )
		{
			if( strncmp( pFaceTemp->szFaceName, pVMDFace->szFaceName, 15 ) == 0 )
			{
				// リストに追加済み
				pFaceTemp->ulNumKeyFrames++;
				break;
			}
			pFaceTemp = pFaceTemp->pNext;
		}

		if( !pFaceTemp )
		{
			// リストにない場合は新規ノードを追加
			FaceDataList	*pNew = new FaceDataList;

			strncpy( pNew->szFaceName, pVMDFace->szFaceName, 15 );	pNew->szFaceName[15] = '\0';
			pNew->ulNumKeyFrames = 1;
			pNew->pNext = NULL;	// 追加

			pNew->pNext = m_pFaceDataList;
			m_pFaceDataList = pNew;
		}
	}

#if (0)
	// キーフレーム配列を確保
	pFaceTemp = m_pFaceDataList;
	m_ulNumFaceNodes = 0;
	while( pFaceTemp )
	{
		pFaceTemp->pKeyFrameList = new FaceKeyFrame[pFaceTemp->ulNumKeyFrames];
		pFaceTemp->ulNumKeyFrames = 0;		// 配列インデックス用にいったん0にする
		pFaceTemp = pFaceTemp->pNext;

		m_ulNumFaceNodes++;
	}
#endif
	
	// 表情ごとにキーフレームを格納
	pVMDFace = (VMD_Face *)pData;

	for( unsigned long i = 0 ; i < ulNumFaceKeyFrames ; i++, pVMDFace++ )
	{
		pFaceTemp = m_pFaceDataList;

		while( pFaceTemp )
		{
			if( strncmp( pFaceTemp->szFaceName, pVMDFace->szFaceName, 15 ) == 0 )
			{
			//	FaceKeyFrame	*pKeyFrame = &(pFaceTemp->pKeyFrameList[pFaceTemp->ulNumKeyFrames]);

				FaceKeyFrameList	*pKeyFrame = new FaceKeyFrameList;
				pKeyFrame->pNext = 0;

				pKeyFrame->fFrameNo = (float)pVMDFace->ulFrameNo;
				pKeyFrame->fRate    =        pVMDFace->fFactor;

			//	pFaceTemp->ulNumKeyFrames++;

				if( !pFaceTemp->pKeyFrameList )
				{
					pFaceTemp->pKeyFrameList = pKeyFrame;
				}
				else
				{
					pKeyFrame->pNext = pFaceTemp->pKeyFrameList;
					pFaceTemp->pKeyFrameList = pKeyFrame;
				}

				break;
			}
			pFaceTemp = pFaceTemp->pNext;
		}
	}

	// キーフレーム配列を昇順にソート
	pFaceTemp = m_pFaceDataList;

	while( pFaceTemp )
	{
	//	qsort( pFaceTemp->pKeyFrameList, pFaceTemp->ulNumKeyFrames, sizeof( FaceKeyFrame ), faceCompareFunc );
		pFaceTemp = pFaceTemp->pNext;
	}

	return true;
}

//======
// 解放
//======
void cVMDMotion::release( void )
{
	// モーションデータの解放
	MotionDataList	*pMotTemp = m_pMotionDataList,
					*pNextMotTemp;

	while( pMotTemp )
	{
		pNextMotTemp = pMotTemp->pNext;

		delete [] pMotTemp->pKeyFrameList;

		delete pMotTemp;

		pMotTemp = pNextMotTemp;
	}

	m_pMotionDataList = NULL;

	// 表情データの解放
	FaceDataList	*pFaceTemp = m_pFaceDataList,
					*pNextFaceTemp;

	while( pFaceTemp )
	{
		pNextFaceTemp = pFaceTemp->pNext;

		delete [] pFaceTemp->pKeyFrameList;

		delete pFaceTemp;

		pFaceTemp = pNextFaceTemp;
	}

	m_pFaceDataList = NULL;
}

void cVMDMotion::sortByFrame( MotionDataList *pMot )
{
	BoneKeyFrameList	*pKeyFrame;
}

void BubbleSortf( float a[], int id[], int n )
{
	int i, j, idt;
	float t;

	for(i = 0; i < n - 1; i++)
		for(j = n - 1; j > i; j--)
			if(a[j - 1] > a[j]) {
				t = a[j];
				a[j] = a[j - 1];
				a[j - 1] = t;

				idt = id[j];
				id[j] = id[j - 1];
				id[j - 1] = idt;
			}
}
